title: 《剑指offer》
date: 2014-09-27 08:05:18
tags: [笔记,面试题, TODO]
---
**写在前面：** 
-----------------
永远记得测试非法的情况。  
当测试个数为0，长度为0，值为NULL的时候。  
对于有序数组，如果所有的数组中存在重复元素会怎样？如果数组中的所有元素都是相同的会怎样？
对于链表，如果指向头/尾指针的时候，如果链表的长度只为1的时候？
Chap2 基本知识
-----------
### 重建二叉树
> 已知二叉树的前序和中序遍历结果，求二叉树

由前序遍历可知树的根节点（即第一个节点）。再在中序遍历中找到对应的位置，该位置左侧均为根节点的左字数，右侧为根节点的右子树。递归处理，最终重建。

### 两个栈实现队列
> 如题

栈1正常压入，要删除时先看栈2是否为空，如果为空就将栈1中的所有元素压到栈2中。如果栈2不为空，则弹出栈2的栈顶。
两个队列实现栈如何做？

Chap3 高质量的代码
--------
### 面题11：数值的整数次方
> 实现`double pow(double base, int exp)`的功能，不需要考虑大数问题。

不难，只是要考虑多种例外情况，如考虑base和exp的取值。  
1. 如果base为0，那么exp不能为负数，否则直接错误并返回（0不能作为除数）
2. 如果exp小于0，那么计算出将exp转为正数后的结果再取倒数。  
3. 另外注意的是，浮点数不能使用`==`来作比较，而应该做差。

小优化：考虑二分的情况，剩下的余数则可以正常相乘。

### 面题12：打印1到最大的n位数
> 可能涉及大数的问题。

其实也就是用字符串模拟自增的行为。  
自增最小位，如果当前位大于10则减去10并将下一位自增1，再看下一位是否大于10，以此作为循环，直到未发生进位。如果循环过程中，偏移量大于n，则说明即将越位，即已经到达最大的位数，那么既可以退出循环。
```c++
void printNumber(int n) {
	if (n <= 0)
	  return;
	char* arr = new char[n+1];
	memset(arr, '0', n+1);
	arr[n] = '\0';
	int j = 0;
	while (1) {
		arr[n-1]++;
		int i = 1;
		while (arr[n-i] - '0' > 9) {
			arr[n-i] -= 10;
			i++;
			if (i > n) break; // 如果i大于n即代表即将越位，直接退出
			arr[n-i]++;
		}
		if (i > n) break;
		int k = 0;
		while (arr[k] == '0') k++; // 将k的位置往后移动到第一个非0数
		for (;k < n; k++) {
			cout << arr[k];
		}
		cout << endl;
	}
}
```
递归的写法仍然不大理解。
**小问题：** 
1. 如何更加有效地表达大数
2. 如何用类似的想法来模拟大数加法

### 面题13：在O(1)时间删除链表节点
> 已知头结点和一个结点指针，如何在O(1)时间删除节点

算是比较简单的题目，删除该节点指针，实际上就是将该下一个节点的值复制到当前节点，将待删除节点的next指针下一个节点的next，再删除下一个节点即可。  
注意几种链表的两种边界情况：
1. 如果待删除节点只有头节点--删除节点后，需要修改头结点指针
2. 如果待删除节点的next是NULL，说明是尾节点，那么需要从头遍历，在O(N)时间内删除，但平均时间还会是O(1)。

### 面题14：调整数组顺序使奇数在偶数前面
> 输入一个数组，调整数组顺序使得奇数在前，偶数在后

楼下是一种蛮通用的方法。  
找两个数，一个从头遍历，一个从尾巴遍历，这是一种很常见的解决方法:
```c++
bool isValid(int value) {
  if (value%2 == 0)
    return true;
  else
    return false;
}
void adjustArr(int A[], bool (*func)(int), int len) {
	int i = 0, j = len - 1;
	while (i < len-1) {
	  while (func(A[i])) i++;
	  while (!func(A[j])) j--;
	  if (i >= j)  break;
	  swap(A[i], A[j]);
	}
}
```

### 面题15：链表的倒数第K个节点
> 输入一个链表，输出链表中的倒数第K个节点

一开始竟然没什么想法。原来可以用两个指针来做，一个指针指向第k个位置的时候，第二个指针开始走。当第一个指针到达最后一个位置的时候，第二个指针指向的就是倒数第k个节点。  
需要注意的仍然是边界值和不合法值：
1. 当头指针为空的时候
2. 当k为0的时候
3. 当链表的长度不到k的时候

类似的题目：
1. 找出链表的中间节点：使用快慢指针
2. 判断单链表是有有环：仍然是快慢指针，如果两个指针都到达了尾指针说明不存在环（看下有没有其他检测方式）**TODO**

### **面题16：翻转链表**
> 输入头指针，翻转该链表

看图来写会比较不容易出错。
```c++
ListNode* reverseNode(ListNode* head) {
	if (head == NULL)
		return;
	ListNode* pReverseHead = NULL; // 记录翻转后的链表头
	ListNode* pNode = head; // 记录当前节点 
	ListNode* pPrev = NULL; // 记录上一个节点
	while (pNode != NULL) {
		ListNode* pNext = pNode->next;
		if (pNext == NULL) pReverseHead = pNode;
		pNode->next = mPrev; // 将当前节点的next指向上一个节点
		mPrev = pNode; // 移动节点位置
		pNode = pNext;
	}
	return pReverseHead;
}
```

### 面题17：合并两个排序的链表
> 输入两个递增的链表，合并两个链表

仍然是主要考虑两个节点都为NULL的情况，其他似乎没什么。

### 面题18：树的子结构 *TODO*
> 输入两个二叉树A和B，判断B是不是A的子树

蛮麻烦的一道题。很值得研究。

### 面题19：二叉树的镜像
> 完成一个函数，输入一个二叉树，输出它的镜像

递归交换左右节点。

### 面题20：顺时针打印矩阵 *TODO*
> RT

先想清楚再动手。画图更好理解，注意边界

### 面题21：包含min函数的栈
> 定义栈的数据结构，实现一个能够得到栈的最小元素的min函数。且三个操作都为O(1)



其他类型
----------------
### 输出全排列
```c
void permute(char* a, int start, int len) {
	if (start == len-1)
		cout << a << endl;
	else {
		int j = 0;
		for (j = start; j < len; j++) {
			swap(a[start], a[j]);
			permute(a, start+1, len);
			swap(a[start], a[j]);
		}
	}
}
```

