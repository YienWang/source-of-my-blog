title: interview question
date: 2014-09-22 13:00:22
tags: [面试,算法]
---
> 三个不同长度的整型数组，每个数组都是有序的。找出同时出现在三个数组中出现的数字的最小值

当时的想法就是归并三个数组，然后从头遍历整个数组，第一次出现连续三次的数字就是最小元素。归并是O(N)的复杂度，遍历一次也是O(N)，整体算法的时间复杂度是O(N)，但空间也是O(N)，不划算。  
后来想了下，其实有更加简单的方式吧。用散列表来做好了。  
假设三个数组分别是A[]，长度N，B[]，长度M，C[]，长度K。先找出最小长度的数组，这里假设是A。对A数组进行一个Hash，算法复杂度是O(1)，接着在对B和C中元素在A的Hash中找元素。并将在该位置的数值加1（注意这里要忽略B和C的重复元素-同理可以去除A中重复元素）。
`A[hash(B[i])]++`

> 如何输出一个字符串中符合IP地址标准的地址

这道题卡壳了。