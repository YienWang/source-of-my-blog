title: 读《Effiective Java》：对于所有对象都通用的方法
date: 2014-09-25 10:54:04
tags: [java,读书,笔记]
---
第三章 对于所有对象都通用的方法
--------------
### 第8条 覆盖`equals`请遵守通用约定
- 要写出好的`equal`有很多规则。
- 【self】你现在只需要记住`==`和`equals`默认是一样的即可= =

### 第9条 覆盖`equals`总是覆盖`hashCode` ###
- 相等的对象必须具有相等的hash code
- 如果不遵守，那么该类无法结合所有基于散列的集合一起工作
- **【self】** 如果你能明确地表示你不会把对象作为散列表的Key，不重写影响似乎不大

例子
```java
Map<Count, String> m = new HashMap<Count, String>();
m.put(new Count(5), "boat");
String content = m.get(new Count(5));
```
在这里`content`会是null，因为前后两个对象的hashCode不一致，在HashMap中的位置也不同，因而无法获取到原本放入的值。解决的方法既简单也复杂，重写`hashCode()`即可。但重写规则有点麻烦，这里不做重点描述= =

### 第10条 始终要覆盖`toString`
- 提供好的toString实现可以使类使用起来更舒适。
- 无论是否指定格式，都为toString返回值中包含所有信息，提供一种编程式的访问途径
- **【self】** 并不是太赞同始终重写，自己实际使用时只是建议重写。

### 第11条 谨慎地覆盖clone
- 简而言之，所有实现了Cloneable接口的类都应该用一个公有的方法覆盖clone。此公有方法首先调用`super.clone()`，然后修正任何需要修正的域（防止浅拷贝）
- 如果你没有为一个类提供良好的clone方法，那么它的子类也不可能实现一个好的Cloneable接口。
- 【self】覆盖clone接口是件非常非常麻烦的事。除了上面要注意的调用链问题，浅拷贝问题，还要注意要调用非虚方法，否则虚方法调用的子类方法会把你逼疯。所以这个接口还是不要用了，就如作者所推荐的，还是提供个工厂方法或者像C++一样提供一个拷贝构造器吧。

### 第12条 考虑实现Comparable接口
- 一旦实现了Compareable接口，就可以与大量泛型算法（如`Array.sort()`）和依赖与该接口实现的集合实现进行协作（如TreeSet）
- 【self】Comparable要求的规则跟equal类似，想要写出完美的接口要验证很多东西。还是觉得简单实在更好

